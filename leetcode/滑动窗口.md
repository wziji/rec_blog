## [滑动窗口思想的理解与运用](https://leetcode-cn.com/circle/discuss/HAOxZA/)

### 0. 滑动窗口思想的理解
滑动窗口是通过双指针同向移动而解决的一类问题。

经常用于数组或者字符串，求其满足条件的子序列或者子串，将原先需要嵌套循环问题，转换为单循环问题，降低时间复杂度。

主要过程：窗口从0开始构建，右指针不断地扩大，直到满足（不满足）条件停止，改为扩大左指针即缩小窗口，直到再次不满足（满足）条件停止，再改为扩大右指针，直至遍历完数组或字符串。

+ 关键点在于：
    + 右指针扩大的时候，什么时候满足条件停止；
    + 左指针收敛的时候，什么时候结束收敛。
        + 一般收敛的结果是要窗口内元素再次满足条件，即多次收敛（while循环），即要找到左指针的正确位置。


### 1. 经典滑动窗口

[3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

当窗口内存在重复元素的时候停止扩大（因为不再满足不重复的条件）。

需要收敛至窗口内出现该重复字符的下一位。

+ 借用map，可以快速判断是否有重复字符且可以快速定位到重复字符的位置；

+ 也可以按上面的模板套路使用while不断收敛（map.remove），直至map.containsKey(array[right])不成立。

```python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        left, right = 0, 0
        max_value = 0
        char_dict = {}

        while right < len(s):
            if s[right] in char_dict:
                left = max(left, char_dict[s[right]] + 1) # 注意+1

            char_dict[s[right]] = right
            max_value = max(max_value, right - left + 1)
            right += 1
        return max_value
```

[209. 长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)

当窗口内的值和大于等于target的时候停止扩大（因为再扩大就不满足寻找最小的条件了）。

收敛至窗口内值和小于target的时候停止。

```python
class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
        result_value = 99999
        left = 0
        right = 0
        sum_value = 0

        while right < len(nums):
            sum_value += nums[right]
            while sum_value >= target:
                result_value = min(result_value, right-left+1)
                sum_value -= nums[left]
                left += 1
            right += 1
        return 0 if result_value == 99999 else result_value
```

[1004. 最大连续1的个数 III](https://leetcode-cn.com/problems/max-consecutive-ones-iii/)

当窗口内的0的值超过k的时候停止扩大（因为再扩大就不满足条件了，最多翻k个）。

收敛至窗口内的值小于等于0停止。

也可参考：[分享滑动窗口模板，秒杀滑动窗口问题](https://leetcode-cn.com/problems/max-consecutive-ones-iii/solution/fen-xiang-hua-dong-chuang-kou-mo-ban-mia-f76z/)

```python
class Solution:
    def longestOnes(self, nums: List[int], k: int) -> int:
        zeros = 0
        left = right = 0
        length = len(nums)
        max_value = 0

        while right < length:
            if nums[right] == 0:
                zeros += 1

            while zeros > k:
                if nums[left] == 0:
                    zeros -= 1
                left += 1

            max_value = max(max_value, right - left + 1)
            right += 1

        return max_value
```

[1208. 尽可能使字符串相等](https://leetcode-cn.com/problems/get-equal-substrings-within-budget/)

当窗口内两字符串对应位置上差值和超过maxCost时停止扩大（因为再扩大就不满足条件了，最大耗费maxCost）。

收敛至窗口内两字符串对应位置上差值和小于等于maxCost停止。

**备注：** 初看此题，蚌埠住了，没懂啥意思。可参考理解下题意：[滑动窗口 - Python 解法](https://leetcode-cn.com/problems/get-equal-substrings-within-budget/solution/python-jie-fa-hua-dong-chuang-kou-by-jiayangwu/)

> 对于每一对下标相等的字符，s[i]和t[i]，把它们转化成相等的 cost 是已知的，cost = abs(ord(t[i]) - ord(s[i]))，所以我们可以直接生成一个数组 record， record[i] 就表示把 s[i] 和 t[i] 转化成相等的 cost。
>
> 接着问题就转化为：在一个数组中，在连续子数组的和小于等于 maxCost 的情况下，找到最长的连续子数组长度。因此可以用滑动窗口解题。


```python
class Solution:
    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:
        temp_list = []
        for i in range(len(s)):
            temp_list.append(abs(ord(s[i]) - ord(t[i])))
        #print(temp_list)
        
        left, right = 0, 0
        max_value = 0
        sum_value = 0

        while right < len(temp_list):
            sum_value += temp_list[right]
            while sum_value > maxCost:
                sum_value -= temp_list[left]
                left += 1
            max_value = max(max_value, right - left + 1)
            right += 1

        return max_value
```

[1493. 删掉一个元素以后全为 1 的最长子数组](https://leetcode-cn.com/problems/longest-subarray-of-1s-after-deleting-one-element/)

当窗口内0的个数超过1的时候停止扩大（因为再扩大就不满足条件了，只能删除一个元素）。

收敛至当窗口内0的个数小于等于1的时候停止。

**备注：** 同 [1004. 最大连续1的个数 III](https://leetcode-cn.com/problems/max-consecutive-ones-iii/)，此题的k=1，最终的结果减去1。

```python
class Solution:
    def longestSubarray(self, nums: List[int]) -> int:
        zeros = 0
        left, right = 0, 0
        result = 0

        while right < len(nums):
            if nums[right] == 0:
                zeros += 1
            while zeros > 1:
                if nums[left] == 0:
                    zeros -= 1
                left += 1
            result = max(result, right - left + 1)
            right += 1

        return result - 1
```

LeetCode3无重复字符的最长子串

当窗口内存在重复元素的时候停止扩大（因为不再满足不重复的条件）

需要收敛至窗口内出现该重复字符的下一位

（借用map，可以快速判断是否有重复字符且可以快速定位到重复字符的位置）

（也可以按上面的模板套路使用while不断收敛（map.remove），直至map.containsKey(array[right])不成立）


public int lengthOfLongestSubstring(String s) {
        int left = 0, right = 0;
        int max = 0;
        char[] array = s.toCharArray();
        Map<Character, Integer> map = new HashMap<>();
        while (right < array.length) {
            // right对应值存在，调整left位置以及计算长度
            if (map.containsKey(array[right])) {
                // 存在重复字符，left需要更新位置：需要注意下的就是更新left位置只更新下标比left大的，
                // 即可能会存在重复字符在left前面的情况，需要过滤
                left = Math.max(left, map.get(array[right]) + 1);
            }
            max = Math.max(max, right - left + 1);
            map.put(array[right], right);
            right++;
        }
        return max;
    }
LeetCode424替换后的最长重复字符

窗口中除了出现次数最多的之外其他元素之和大于k的时候，停止继续扩大窗口，因为此时已经不满足最多替换k次后是重复字符

当不满足条件之后，左端口向前一步，再重新计算max，不断向前收敛


public int characterReplacement(String s, int k) {
        int left = 0, right = 0;
        int max = 0, ans = 0;
        Map<Character, Integer> map = new HashMap<>();
        while (right < s.length()) {
            map.put(s.charAt(right), map.getOrDefault(s.charAt(right), 0) + 1);
            // 更新出现次数的最大值
            max = Math.max(max, map.get(s.charAt(right)));
            // 当除了出现次数最多的元素之外 其他元素的数量大于k时，不再满足条件，需要缩小窗口
            while (right - left + 1 - max > k) {
                map.put(s.charAt(left), map.get(s.charAt(left)) - 1);
                // 重新计算max
                max = handleMax(map);
                left++;
            }
            ans = Math.max(ans, right - left + 1);
            right++;
        }
        return ans;
    }
这道题官方给的解法收敛的时候只收敛一次，不用更新max


内层循环里的 if 能不能改成 while?
答：可以但没有必要。理由依然是：我们只关心最长替换 k 次以后重复子串的长度。

正是因为多读了一个字符，使得 right - left > maxCount + k 成立；
在 left++ 以后，由于可以不维护 maxCount 的定义，right - left > maxCount + k 不成立。因此 if 里面的代码块只会被执行一次。
理解起来不是很好理解，但是效率更高


public int characterReplacement(String s, int k) {
        int left = 0, right = 0;
        int max = 0, ans = 0;
        int[] nums = new int[26];
        while (right < s.length()) {
            nums[s.charAt(right) - 'A']++;
            // 更新出现次数的最大值
            max = Math.max(max, nums[s.charAt(right) - 'A']);
            // 当除了出现次数最多的元素之外 其他元素的数量大于k时，不再满足条件，需要缩小窗口
            // 收敛一次
            if (right - left + 1 - max > k) {
                nums[s.charAt(left) - 'A']--;
                left++;
            } else {
                ans = Math.max(ans, right - left + 1);
            }
            right++;
        }
        return ans;
    }
LeetCode30串联所有单词的子串

应用滑动窗口的一道困难题

双map，不断地将one_len的字串加到工作map中

当工作map中该子串的数量大于原map，停止添加（停止扩大窗口）

收敛至工作map中该子串的数量小于等于原map停止（left的正确位置，确保了没有超数的子串）


public List<Integer> findSubstring(String s, String[] words) {
        List<Integer> ans = new ArrayList<>();
        int one_len = words[0].length();
        Map<String, Integer> map = new HashMap<>();
        for (String word : words) {
            map.put(word, map.getOrDefault(word, 0) + 1);
        }
        Map<String, Integer> work = new HashMap<>();
        int count = 0;
        // 最开始就这边的one_len次循环不是很理解，也很难想到；循环one_len次即能保证以步长one_len遍历整个字符串
        for (int i = 0; i < one_len; i++) {
            int left = i, right = i + one_len;
            while (right <= s.length()) {
                String curr_str = s.substring(right - one_len, right);
                if (!map.containsKey(curr_str)) {
                    // map中不包含当前截取的字符串，直接向下滑动，left等于当前right，right向前步长one_len
                    left = right;
                    count = 0;
                    work.clear();
                } else {
                    // map中包含该key，加入work_map中
                    work.put(curr_str, work.getOrDefault(curr_str, 0) + 1);
                    count++;
                    // 如果当前字符在work_map中出现的次数大于原始map中，表明当前开始的left是不合规的，需要从work_map中剔除元素，直到当前字符curr_str出现的次数小于等于原始map
                    while (work.get(curr_str) > map.get(curr_str)) {
                        String left_str = s.substring(left, left + one_len);
                        work.put(left_str, work.get(left_str) - 1);
                        count--;
                        left += one_len;
                    }
                    if (count == words.length) ans.add(left);
                }
                // right继续以步长one_len向前
                right += one_len;
            }
            // work_map、count清空下，重新开始下一次循环
            work.clear();
            count = 0;
        }
        return ans;
    }
LeetCode76最小覆盖子串

应用滑动窗口的一道困难题

使用三个map

当窗口内元素能够将tWorkMap中所有所有元素覆盖（清空），停止扩大窗口，此时找到了一组解

再缩小窗口，直至该组解不成立（结束收敛）

当准备收敛的元素在tMap和sMap中出现的次数一样，即表明该元素是组成上一组解的必要元素，再次将其添加到tWorkMap中，此时收敛到该元素，上一组解将不再成立

最后在收敛的过程中记录最小值


public String minWindow(String s, String t) {
        if (s.length() < t.length()) return "";
        Map<Character, Integer> tMap = new HashMap<>();
        Map<Character, Integer> sMap = new HashMap<>();
        for (char ch : t.toCharArray()) {
            tMap.put(ch, tMap.getOrDefault(ch, 0) + 1);
        }
        Map<Character, Integer> tWorkMap = new HashMap<>(tMap);
        int left = 0, right = 0;
        int min = Integer.MAX_VALUE, location = 0;
        while (right < s.length()) {
            // 窗口不断扩大，将窗口元素放入sMap中
            sMap.put(s.charAt(right), sMap.getOrDefault(s.charAt(right), 0) + 1);
            // 窗口扩大的过程中，当将tWorkMap中所有元素置空完毕，则找到一组解
            int count = tWorkMap.getOrDefault(s.charAt(right), 0);
            if (count > 1) {
                tWorkMap.put(s.charAt(right), count - 1);
            } else if (count == 1) {
                tWorkMap.remove(s.charAt(right));
            }
            // 找到一组解之后缩小窗口，直至窗口内元素不再满足条件 即tWorkMap再次有元素
            while (tWorkMap.size() == 0) {
                // 记录最优解
                if (min > right - left + 1) {
                    min = right - left + 1;
                    location = left;
                }
                int num1 = tMap.getOrDefault(s.charAt(left), 0);
                int num2 = sMap.get(s.charAt(left));
                // 准备收敛的元素在tMap和sMap中出现的次数一样，即表明该元素是组成上一组解的必要元素，再次将其添加到tWorkMap中
                // 也就是说遍历到了该元素，上一组解将不再成立
                if (num1 == num2) {
                    tWorkMap.put(s.charAt(left), 1);
                }
                // 收敛sMap
                sMap.put(s.charAt(left), num2 - 1);
                left++;
            }
            right++;
        }
        return min == Integer.MAX_VALUE ? "" : s.substring(location, location + min);
    }
定长滑动窗口
窗口大小固定：只需要维护一位指针，另一位指针可以通过+-k得到

定长滑动窗口不需要一直收敛，因为长度固定，当达到窗口长度的时候判断是否符合条件，然后收敛一次（左指针前进一步）,右指针也是前进一步，再重复判断

LeetCode438找到字符串中所有字母异位词

窗口范围[i-len,i]，当i >= len需要收敛左指针一位


public List<Integer> findAnagrams(String s, String p) {
        List<Integer> ans = new ArrayList<>();
        int len = p.length();
        if (s.length() < len || len == 0) return ans;
        int[] sNums = new int[26];
        int[] pNums = new int[26];
        for (char ch : p.toCharArray()) {
            pNums[ch - 'a']++;
        }
        for (int i = 0; i < s.length(); i++) {
            // 定长滑动窗口，超出窗口范围，收敛
            if (i >= len) {
                sNums[s.charAt(i - len) - 'a']--;
            }
            sNums[s.charAt(i) - 'a']++;
            // 当窗口内元素等于len的时候，开始判断
            if (i >= len - 1 && Arrays.equals(sNums, pNums)) {
                ans.add(i - len + 1);
            }
        }
        return ans;
    }
LeetCode567字符串的排列

窗口范围[i-len1,i]，当i >= len需要收敛左指针一位


public boolean checkInclusion(String s1, String s2) {
        int len1 = s1.length(), len2 = s2.length();
        if (len1 > len2) return false;
        int[] s1Nums = new int[26];
        int[] s2Nums = new int[26];
        for (char ch : s1.toCharArray()) s1Nums[ch - 'a']++;
        for (int i = 0; i < len2; i++) {
            // 定长滑动窗口，当窗口超出范围，收敛
            if (i >= len1) {
                s2Nums[s2.charAt(i - len1) - 'a']--;
            }
            s2Nums[s2.charAt(i) - 'a']++;
            if (i >= len1 - 1 && Arrays.equals(s1Nums, s2Nums)) {
                return true;
            }
        }
        return false;
    }
LeetCode219存在重复元素 II


public boolean containsNearbyDuplicate(int[] nums, int k) {
        Set<Integer> set = new HashSet<>();
        for (int i = 0, len = nums.length; i < len; i++) {
            if (i > k) {
                // 继续移动窗口，需要把最前面的元素移除掉
                set.remove(nums[i - k - 1]);
            }
            // add方法可以直接判断set中是否有该元素
            if (!set.add(nums[i])) {
                return true;
            }
        }
        return false;
    }
LeetCode220存在重复元素 III

思想类似于存在重复元素II，难点在于要选择合适的数据结构，便于寻找与a最接近的数（寻找最小绝对差）


/*
    类似于存在重复元素II，当窗口滑到新元素a，这里需要找到窗口内与a最接近的元素，看他们的绝对差是否小于t
    寻找最接近的元素，可以考虑在有序集合中利用二分查找，时间复杂度 logn
    综合以上可以考虑使用treeSet数据结构，基于红黑树形成的有序且平衡的树，并且基于set的机制，不允许添加重复元素，搜索时间复杂度 logn
     */
    public boolean containsNearbyAlmostDuplicate02(int[] nums, int k, int t) {
        if (k == 0 || nums.length == 0) return false;
        TreeSet<Long> treeSet = new TreeSet<>();
        for (int i = 0; i < nums.length; i++) {
            if (i > k) {
                treeSet.remove((long) nums[i - k - 1]);
            }
            // 大于等于的最小值
            Long low = treeSet.ceiling((long) nums[i] - (long) t);
            // 大于等于num-t的最小值，看齐是否小于num+t
            if (low != null && low <= (long) t + (long) nums[i]) {
                return true;
            }
            treeSet.add((long) nums[i]);
        }
        return false;
    }
LeetCode239滑动窗口最大值

这道题的难度在于如何找到窗口内的最大值，以及在一进一出的过程中如何维护最大值

如果每次都遍历窗口寻找最大值，时间复杂度O(k)

总时间复杂度O(nk)，数据量变大的时候会超时

那就要考虑使用合适的数据结构了：O(1)的复杂度查找到最大值

单调队列：将最大值存在队列头部，然后依次递减


维护：
当一个新的元素需要加入队列的时候，不断的与队尾比较，如果比队尾元素大，移除队尾元素，直至比队尾元素小入队（因为较小的元素可以直接移除掉，不会对答案产生影响，以便下次的时候无需再访问）
当滑动窗口移出元素的时候，如果是队头的最大元素，将对头元素去掉

/*
    上一种方法当滑动窗口出队列的元素是最大值的时候，需要重新遍历k的长度寻找最大值
    这道题的难点就在于如何找到窗口内的最大值，以及在窗口一进一出的过程中，怎么维护最大值
    1. 优先队列，能够保证每次出队的元素是按顺序的
    2. 单调队列，队列中元素是单调递增（递减）
     */
    public int[] maxSlidingWindow(int[] nums, int k) {
        int len = nums.length;
        if (len < k) return new int[0];
        int[] ans = new int[len - k + 1];
        int count = 0;
        // 如何维护单调队列，当一个新的元素需要加入队列的时候，不断的与队尾比较，如果比队尾元素大，移除队尾元素，直至比队尾元素小入队
        // 当滑动窗口移出元素的时候，如果是队头的最大元素，将对头元素去掉
        Deque<Integer> queue = new LinkedList<>();
        for (int i = 0; i < len; i++) {
            // 不断的与队尾元素比较，当大于队尾元素的时候，需要找到他合适的位置
            while (!queue.isEmpty() && queue.peekLast() < nums[i]) {
                queue.pollLast();
            }
            queue.addLast(nums[i]);
            if (i >= k) {
                // 如果滑出去的值是最大值，将队头的最大值出队，此时队列第二个元素将会是最大值
                if (nums[i - k] == queue.peekFirst()) {
                    queue.pollFirst();
                }
            }
            if (i >= k - 1) {
                ans[count++] = queue.peekFirst();
            }
        }
        return ans;
    }

### 总结
使用滑动窗口关键点在于理清两个逻辑：
+ 右指针扩大的时候，什么时候满足条件停止；
+ 左指针收敛的时候，什么时候结束收敛。
剩下的就是善用数据结构，想办法满足停止或者收敛条件即可。
